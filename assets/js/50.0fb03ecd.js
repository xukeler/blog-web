(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{587:function(_,v,e){"use strict";e.r(v);var t=e(31),l=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h3",{attrs:{id:"restful"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#restful"}},[_._v("#")]),_._v(" restful")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("REST")]),_._v("全称是"),e("code",[_._v("Representational State Transfer")]),_._v("，中文意思是表述性状态转移。 "),e("code",[_._v("REST")]),_._v("指的是一组架构约束条件和原则。如果一个架构符合"),e("code",[_._v("REST")]),_._v("的约束条件和原则，我们就称它为"),e("code",[_._v("RESTful")]),_._v("架构。")]),_._v(" "),e("li",[_._v("直接理解就是"),e("code",[_._v("REST")]),_._v(" 指的是 一组架构约束条件和原则，如果一个架构符合 "),e("code",[_._v("REST")]),_._v(" 的约束条件和原则，就称之为 "),e("code",[_._v("RESTful")]),_._v(" 架构。")]),_._v(" "),e("li",[e("code",[_._v("RESTful")]),_._v(" 是一种 "),e("code",[_._v("web")]),_._v(" 服务设计风格，而不是标准,不是标准就意味着可以按照这个风格来，也可以不按照这个风格来。")]),_._v(" "),e("li",[e("a",{attrs:{href:"http://restful.p2hp.com/",target:"_blank",rel:"noopener noreferrer"}},[_._v("官网"),e("OutboundLink")],1)])]),_._v(" "),e("h3",{attrs:{id:"rest架构风格的设计原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rest架构风格的设计原则"}},[_._v("#")]),_._v(" REST架构风格的设计原则")]),_._v(" "),e("ul",[e("li",[e("h4",{attrs:{id:"客户端-服务器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#客户端-服务器"}},[_._v("#")]),_._v(" 客户端-服务器")]),_._v(" "),e("ul",[e("li",[_._v("客户端-服务器结构限制的目的是将客户端和服务器端的关注点分离。将用户界面数据存储所关注的逻辑分离开来有助于提高用户界面的跨平台的可移植性，通过简化服务器模块也有助于服务器模块的可扩展性")])])]),_._v(" "),e("li",[e("h4",{attrs:{id:"无状态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#无状态"}},[_._v("#")]),_._v(" 无状态")]),_._v(" "),e("ul",[e("li",[_._v("服务器不能保存客户端的信息每一次从客户端发送的请求中, 要包含所有的状态信息, 会话信息由客户端保存, 服务器端根据这些状态信息来处理请求。服务器可以将会话状态信息传递给其他服务, 比如数据库服务, 这样可以保持一段时间的状态信息, 从而实现认证功能。当客户端可以切换到一个新状态的时候发送请求信息。当一个或者多个请求被发送之后, 客户端就处于一个状态变迁过程中。 每一个应用的状态描述可以被客户端用来初始化下一次的状态变迁")])])]),_._v(" "),e("li",[e("h4",{attrs:{id:"缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[_._v("#")]),_._v(" 缓存")]),_._v(" "),e("ul",[e("li",[_._v("如同万维网一样, 客户端和中间的通讯传递者可以将回复缓存起来。回复必须明确的或者间接的表明本身是否可以进行缓存, 这可以预防客户端在将来进行请求的时候得到陈旧的或不恰当的数据。管理良好的缓存机制可以减少客户端-服务器之间的交互, 甚至完全避免客户端-服务器交互, 这进一步提了高性能和可扩展性")])])]),_._v(" "),e("li",[e("h4",{attrs:{id:"统一接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#统一接口"}},[_._v("#")]),_._v(" 统一接口")]),_._v(" "),e("ul",[e("li",[_._v("这是 "),e("code",[_._v("RESTful")]),_._v(" 系统设计的基本出发点。它简化了系统架构, 减少了耦合性, 可以让所有模块各自独立的进行改进各自独立的进行改进")])])])]),_._v(" "),e("h3",{attrs:{id:"理解restful"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#理解restful"}},[_._v("#")]),_._v(" 理解RESTful")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("restful")]),_._v("架构中都是通过"),e("code",[_._v("url")]),_._v("来一一对应资源,"),e("code",[_._v("url")]),_._v("既可以看成是资源的地址，也可以看成是资源的名称，代表的就是唯一的资源，但是不能表示对资源的操作，操作是结合标准的"),e("code",[_._v("http")]),_._v("方法（"),e("code",[_._v("get、post、put")]),_._v("等）来实现的。")]),_._v(" "),e("li",[_._v("资源指的是网络上的一个具体信息，例如一张图片，一段文字、一种服务。总之就是一个实际存在的东西，而 "),e("code",[_._v("URL")]),_._v("就是用来指向这个资源的。")]),_._v(" "),e("li",[e("code",[_._v("restful")]),_._v("架构应该遵循统一接口原则，统一接口包含了一组受限的预定义的操作，不论什么样的资源，都是通过使用相同的接口进行资源的访问。接口应该使用标准的"),e("code",[_._v("http")]),_._v("方法如"),e("code",[_._v("get,put,delelte")]),_._v("和"),e("code",[_._v("post")]),_._v("，并遵循这些方法的语义。")]),_._v(" "),e("li",[_._v("如果按照"),e("code",[_._v("http")]),_._v("方法的语义来暴露资源("),e("code",[_._v("http")]),_._v("方法的定义有两点安全性和幂等性)，那么接口将会拥有安全性和幂等性的特性(幂等性:就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用),而"),e("code",[_._v("get、head、put")]),_._v("和"),e("code",[_._v("delete")]),_._v("请求都是幂等的，无论对资源操作多少次， 结果总是一样的，后面的请求并不会产生比第一次更多的影响。\n"),e("ul",[e("li",[e("code",[_._v("get")]),_._v(" 安全、幂等，用于获取资源。")]),_._v(" "),e("li",[_._v("安全、幂等，与"),e("code",[_._v("get")]),_._v("方法类似，但不返回"),e("code",[_._v("message body")]),_._v("内容，仅仅是获得获取资源的部分信息\n"),e("code",[_._v("restful")]),_._v("框架中较少使用。")]),_._v(" "),e("li",[e("code",[_._v("post")]),_._v("非安全、非幂等,用于创建子资源。")]),_._v(" "),e("li",[e("code",[_._v("put")]),_._v("非安全、幂等,用于创建、更新资源。")]),_._v(" "),e("li",[e("code",[_._v("delete")]),_._v("非安全、幂等，删除资源。")]),_._v(" "),e("li",[e("code",[_._v("options")]),_._v("安全、幂等，用于url验证，验证接口服务是否正常。")]),_._v(" "),e("li",[e("code",[_._v("patch")]),_._v("非安全、幂等，用于创建、更新资源，于"),e("code",[_._v("put")]),_._v("类似，区别在于"),e("code",[_._v("patch")]),_._v("代表部分更新。")])])])]),_._v(" "),e("h3",{attrs:{id:"restful-api接口规范"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#restful-api接口规范"}},[_._v("#")]),_._v(" Restful API接口规范")]),_._v(" "),e("ul",[e("li",[e("p",[e("code",[_._v("restful API")]),_._v("的接口架构风格中制定了一些规范，极大的简化了前后端对接的时间，以及增加了开发效率，在实际开发中，比如在获取列表分页的时候，对于查询参数过多的接口，会导致uri的长度过长、请求失败，在这种情况下的接口就不能完全按照"),e("code",[_._v("Restful API")]),_._v("的请求规范来。"),e("code",[_._v("Restful API")]),_._v("也就只是一种接口架构的风格，接口"),e("code",[_._v("API")]),_._v("永远不会强约束于此，因按照实际需求做出相应的接口需改。")])]),_._v(" "),e("li",[e("h4",{attrs:{id:"http状态码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http状态码"}},[_._v("#")]),_._v(" http状态码")]),_._v(" "),e("ul",[e("li",[_._v("使用"),e("code",[_._v("http")]),_._v("状态码定义"),e("code",[_._v("api")]),_._v("执行结果，"),e("code",[_._v("http")]),_._v("定义了一系列可以用在接口返回的有含义的状态码。\n"),e("ul",[e("li",[e("code",[_._v("4xx")]),_._v("客户端错误")]),_._v(" "),e("li",[e("code",[_._v("5xx")]),_._v("服务端错误")]),_._v(" "),e("li",[e("code",[_._v("3xx")]),_._v("服务端资源错误")]),_._v(" "),e("li",[e("code",[_._v("2xx")]),_._v("请求成功")])])])])]),_._v(" "),e("li",[e("h4",{attrs:{id:"路径规范"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#路径规范"}},[_._v("#")]),_._v(" 路径规范")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("/")]),_._v("分隔符一般用来对资源层级的划分，例如 "),e("code",[_._v("http://api.domain.com/school/classes")]),_._v("\n对于"),e("code",[_._v("REST API")]),_._v("来说，"),e("code",[_._v("/")]),_._v("只是一个分隔符，并无其他含义。为了避免混淆，"),e("code",[_._v("/")]),_._v("不应该出现在"),e("code",[_._v("URL")]),_._v("的末尾。"),e("code",[_._v("REST API")]),_._v("对"),e("code",[_._v("URI")]),_._v("资源的定义具有唯一性，一个资源对应一个唯一的地址。为了使接口保持清晰干净，如果访问到末尾包含"),e("code",[_._v("/")]),_._v(" 的地址，服务端应该"),e("code",[_._v("301")]),_._v("到没有 "),e("code",[_._v("/")]),_._v("的地址上。当然这个规则也仅限于"),e("code",[_._v("REST API")]),_._v("接口的访问，对于传统的"),e("code",[_._v("WEB")]),_._v("页面服务来说，并不一定适用这个规则")]),_._v(" "),e("li",[_._v("路径中使用连字符 "),e("code",[_._v("-")]),_._v("代替下划线"),e("code",[_._v("_")]),_._v("。")]),_._v(" "),e("li",[_._v("路径中统一使用小写字母")])])]),_._v(" "),e("li",[e("h4",{attrs:{id:"请求方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请求方式"}},[_._v("#")]),_._v(" 请求方式")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("get")]),_._v("查询操作")]),_._v(" "),e("li",[e("code",[_._v("post")]),_._v("新增操作")]),_._v(" "),e("li",[e("code",[_._v("put")]),_._v("更新操作")]),_._v(" "),e("li",[e("code",[_._v("patch")]),_._v("部分更新")]),_._v(" "),e("li",[e("code",[_._v("delete")]),_._v("删除操作")])])])])])}),[],!1,null,null,null);v.default=l.exports}}]);