(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{575:function(v,_,e){"use strict";e.r(_);var t=e(31),l=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h3",{attrs:{id:"面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#面试题"}},[v._v("#")]),v._v(" 面试题")]),v._v(" "),e("h3",{attrs:{id:"css"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css"}},[v._v("#")]),v._v(" Css")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("什么是盒模型")]),v._v(" "),e("ul",[e("li",[v._v("内容"),e("code",[v._v("content")]),v._v("、填充"),e("code",[v._v("padding")]),v._v("、边框"),e("code",[v._v("border")]),v._v("、边界"),e("code",[v._v("margin")]),v._v(" 。")])])]),v._v(" "),e("li",[e("p",[v._v("怎么居中一个"),e("code",[v._v("div")])]),v._v(" "),e("ul",[e("li",[e("code",[v._v("flex")]),v._v("布局 "),e("code",[v._v("align-items:center;justify-content:center")])]),v._v(" "),e("li",[v._v("绝对定位"),e("code",[v._v("position:absolute;top:50%;left:50%;transform:translateX(-50%);translateY(-50%)")]),v._v("。")]),v._v(" "),e("li",[v._v("转换为行内元素"),e("code",[v._v("display:inline-block;")]),v._v("，父级使用"),e("code",[v._v("text-align:center")]),v._v("。")]),v._v(" "),e("li",[v._v("水平居中"),e("code",[v._v("margin:0 auto")]),v._v("。")])])]),v._v(" "),e("li",[e("p",[v._v("哪些"),e("code",[v._v("css")]),v._v("属性可以被继承")]),v._v(" "),e("ul",[e("li",[v._v("所有元素都可以继承"),e("code",[v._v("cursor")]),v._v("，"),e("code",[v._v("visibility")]),v._v("。")]),v._v(" "),e("li",[v._v("内联元素可继承 "),e("code",[v._v("letter-spacing word-spacing white-space line-height color font font-family font-size font-style font-variant font-weight ext-decoration text-transform")]),v._v(",")]),v._v(" "),e("li",[v._v("块级元素可以继承"),e("code",[v._v("text-align")]),v._v("。")])])]),v._v(" "),e("li",[e("p",[v._v("文本溢出显示三个点")]),v._v(" "),e("div",{staticClass:"language-css line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-css"}},[e("code",[v._v(" "),e("span",{pre:!0,attrs:{class:"token property"}},[v._v("overflow")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v("hidden"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n "),e("span",{pre:!0,attrs:{class:"token property"}},[v._v("white-space")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v("nowrap"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n "),e("span",{pre:!0,attrs:{class:"token property"}},[v._v("text-overflow")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v("ellipsis"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])]),v._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[v._v("1")]),e("br"),e("span",{staticClass:"line-number"},[v._v("2")]),e("br"),e("span",{staticClass:"line-number"},[v._v("3")]),e("br")])])]),v._v(" "),e("li",[e("p",[v._v("页面导入样式时，使用link和@import有什么区别")]),v._v(" "),e("ul",[e("li",[v._v("link是跟着页面加载同时加载的，但是@import会等到页面加载完再加载")])])]),v._v(" "),e("li",[e("p",[v._v("css优先级")]),v._v(" "),e("ul",[e("li",[v._v("优先级从高到低 "),e("code",[v._v("!important")]),v._v(">内联样式>"),e("code",[v._v("id")]),v._v(">"),e("code",[v._v("class")]),v._v(">标签")])])]),v._v(" "),e("li",[e("p",[v._v("清除浮动")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("overflow:hidden;")]),v._v("清除")]),v._v(" "),e("li",[v._v("伪元素清除")])]),v._v(" "),e("div",{staticClass:"language-css line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-css"}},[e("code",[e("span",{pre:!0,attrs:{class:"token selector"}},[v._v(".clearfix:after")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n    content="),e("span",{pre:!0,attrs:{class:"token string"}},[v._v('""')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n    "),e("span",{pre:!0,attrs:{class:"token property"}},[v._v("display")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v("block"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n    "),e("span",{pre:!0,attrs:{class:"token property"}},[v._v("clear")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v("both"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n    "),e("span",{pre:!0,attrs:{class:"token property"}},[v._v("height")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v("0"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n")])]),v._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[v._v("1")]),e("br"),e("span",{staticClass:"line-number"},[v._v("2")]),e("br"),e("span",{staticClass:"line-number"},[v._v("3")]),e("br"),e("span",{staticClass:"line-number"},[v._v("4")]),e("br"),e("span",{staticClass:"line-number"},[v._v("5")]),e("br"),e("span",{staticClass:"line-number"},[v._v("6")]),e("br")])])]),v._v(" "),e("li",[e("p",[v._v("去除行内块的默认边距")]),v._v(" "),e("ul",[e("li",[v._v("给父元素设置"),e("code",[v._v("font-size:0")]),v._v("。")]),v._v(" "),e("li",[v._v("浮动"),e("code",[v._v("float")])])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("transition")]),v._v("和"),e("code",[v._v("animation")]),v._v("的区别")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("transition")]),v._v("是过度效果,已经设置好的样式的过渡，并没有真正的动画行为,需要行为触发。")]),v._v(" "),e("li",[e("code",[v._v("animation")]),v._v("是动画效果，可以从开始到结束,中间穿插各种动画效果，不需要行为触发。")])])]),v._v(" "),e("li",[e("p",[v._v("隐藏一个元素")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("display:none")])]),v._v(" "),e("li",[e("code",[v._v("visibility:hidden")])]),v._v(" "),e("li",[e("code",[v._v("z-index=-1")])]),v._v(" "),e("li",[e("code",[v._v("opacity：0")])])])]),v._v(" "),e("li",[e("p",[v._v("为什么"),e("code",[v._v("css")]),v._v("放在顶部而"),e("code",[v._v("js")]),v._v("写在后面？")]),v._v(" "),e("ul",[e("li",[v._v("浏览器预先加载"),e("code",[v._v("css")]),v._v("后，可以不必等待"),e("code",[v._v("HTML")]),v._v("加载完毕就可以渲染页面了")]),v._v(" "),e("li",[v._v("其实"),e("code",[v._v("HTML")]),v._v("渲染并不会等到完全加载完在渲染页面，而是一边解析"),e("code",[v._v("DOM")]),v._v("一边渲染。")]),v._v(" "),e("li",[e("code",[v._v("js")]),v._v("写在尾部，主要是因为"),e("code",[v._v("js")]),v._v("主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更加的加载，提高用户的良好体验")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("Css3")]),v._v("新特性")]),v._v(" "),e("ul",[e("li",[v._v("动画"),e("code",[v._v("animation")])]),v._v(" "),e("li",[e("code",[v._v("flex")]),v._v("布局")]),v._v(" "),e("li",[e("code",[v._v("transition")]),v._v("过渡")]),v._v(" "),e("li",[v._v("媒体查询"),e("code",[v._v("@media")])]),v._v(" "),e("li",[v._v("字体"),e("code",[v._v("@font-face")])]),v._v(" "),e("li",[v._v("转换"),e("code",[v._v("transform")])]),v._v(" "),e("li",[v._v("圆角边框")])])]),v._v(" "),e("li",[e("p",[v._v("为什么要初始化"),e("code",[v._v("CSS")]),v._v("样式")]),v._v(" "),e("ul",[e("li",[v._v("因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("margin")]),v._v("重合")]),v._v(" "),e("ul",[e("li",[v._v("在重合元素外包裹一层容器,设置"),e("code",[v._v("overflow:hidden")]),v._v("，一般会避免这个问题。")])])]),v._v(" "),e("li",[e("p",[v._v("BFC及其应用")]),v._v(" "),e("ul",[e("li",[v._v("BFC （块级格式化上下文），是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响，它属于定位方案的普通流。")]),v._v(" "),e("li",[v._v("阻止元素被浮动元素覆盖")]),v._v(" "),e("li",[v._v("止相邻元素的margin合并")])])])]),v._v(" "),e("h2",{attrs:{id:"html面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#html面试题"}},[v._v("#")]),v._v(" html面试题")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("html语义化的理解")]),v._v(" "),e("ul",[e("li",[v._v("选择与语义相符合的标签，使代码语义化，这样不仅便于开发者进行阅读，同时也能维护和写出更优雅的代码，还能够让搜索引擎和浏览器等工具更好地解析。")])])]),v._v(" "),e("li",[e("p",[v._v("meta viewport 是做什么用的")]),v._v(" "),e("ul",[e("li",[v._v("将页面展示为可视区域的大小。")])])]),v._v(" "),e("li",[e("p",[v._v("如何保证在移动端不自动缩放网页的尺寸")]),v._v(" "),e("ul",[e("li",[v._v("viewport 设置scale为1")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("HTML5")]),v._v("新特性")]),v._v(" "),e("ul",[e("li",[v._v("语意化标签"),e("code",[v._v("(nav、aside、dialog、header、footer等)")])]),v._v(" "),e("li",[e("code",[v._v("canvas")]),v._v("、 "),e("code",[v._v("svg")])]),v._v(" "),e("li",[v._v("拖放相关api")]),v._v(" "),e("li",[e("code",[v._v("Audio")]),v._v("、"),e("code",[v._v("Video")]),v._v("媒体标签")]),v._v(" "),e("li",[e("code",[v._v("web")]),v._v("存储"),e("code",[v._v("localStorage")]),v._v("、"),e("code",[v._v("sessionStorage")])]),v._v(" "),e("li",[e("code",[v._v("websocket")])])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("script")]),v._v(" 标签为什么要放在 "),e("code",[v._v("body")]),v._v(" 标签的底部")]),v._v(" "),e("ul",[e("li",[v._v("因为浏览器在渲染"),e("code",[v._v("html")]),v._v("的时候是从上到下执行的，当遇到"),e("code",[v._v("js")]),v._v("文件的时候就会停止当前页面的渲染，转而去下载"),e("code",[v._v("j")]),v._v("s文件，如果将"),e("code",[v._v("script")]),v._v("标签放在头部，在文件很大的情况下将导致首屏加载时间延长，影响用户体验。")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("DOCTYPE")]),v._v(" 标签")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("DOCTYPE")]),v._v("声明于文档最前面，告诉浏览器以何种方式来渲染页面。")])]),v._v(" "),e("div",{staticClass:"language-html line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-html"}},[e("code",[e("span",{pre:!0,attrs:{class:"token doctype"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("<!")]),e("span",{pre:!0,attrs:{class:"token doctype-tag"}},[v._v("DOCTYPE")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token name"}},[v._v("html")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(">")])]),v._v("\n\n")])]),v._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[v._v("1")]),e("br"),e("span",{staticClass:"line-number"},[v._v("2")]),e("br")])])]),v._v(" "),e("li",[e("p",[v._v("从输入网址"),e("code",[v._v("URL")]),v._v("到页面显示的过程")]),v._v(" "),e("ul",[e("li",[v._v("域名解析，对输入的"),e("code",[v._v("url")]),v._v("进行"),e("code",[v._v("dns")]),v._v("域名解析，得到对应的"),e("code",[v._v("ip")]),v._v("地址")]),v._v(" "),e("li",[v._v("根据这个"),e("code",[v._v("ip")]),v._v("地址，找到对应的服务器，发起"),e("code",[v._v("tcp")]),v._v("连接（三次握手）")]),v._v(" "),e("li",[v._v("建立"),e("code",[v._v("tcp")]),v._v("连接后发送"),e("code",[v._v("http")]),v._v("请求")]),v._v(" "),e("li",[v._v("服务器响应"),e("code",[v._v("http")]),v._v("请求，浏览器得到"),e("code",[v._v("html")]),v._v("代码")]),v._v(" "),e("li",[v._v("浏览器解析"),e("code",[v._v("html")]),v._v("代码，并请求"),e("code",[v._v("html")]),v._v("代码中的"),e("code",[v._v("js、css")]),v._v("、图片等资源")]),v._v(" "),e("li",[v._v("浏览器对页面进行渲染并呈现给用户")]),v._v(" "),e("li",[v._v("断开"),e("code",[v._v("TCP")]),v._v("连接（四次挥手）")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("html")]),v._v("页面渲染过程")]),v._v(" "),e("ul",[e("li",[v._v("解析"),e("code",[v._v("html")]),v._v("文件，创建"),e("code",[v._v("DOM")]),v._v("树")]),v._v(" "),e("li",[v._v("解析"),e("code",[v._v("css")]),v._v("，生成"),e("code",[v._v("CSSOM")]),v._v("（"),e("code",[v._v("CSS Object Model")]),v._v("），即"),e("code",[v._v("CSS")]),v._v("对象模型")]),v._v(" "),e("li",[e("code",[v._v("dom")]),v._v("和"),e("code",[v._v("css")]),v._v("合并，构建渲染树（"),e("code",[v._v("render tree")]),v._v("）")]),v._v(" "),e("li",[e("code",[v._v("layout")]),v._v(" 布局（渲染）, 依照盒子模型，计算每个节点在屏幕中的尺寸和位置")]),v._v(" "),e("li",[e("code",[v._v("painting")]),v._v(" 绘制（渲染）按照计算出来的规则，通过显卡，将内容画到屏幕上")]),v._v(" "),e("li",[v._v("重排（即重新"),e("code",[v._v("layout")]),v._v("）：当课件节点位置或者尺寸发生变化事会发生重排")]),v._v(" "),e("li",[v._v("重绘（即重新"),e("code",[v._v("paint")]),v._v("）：改变某个元素的背景色、文字颜色等不影响它周围或内部布局的属性时，屏幕的一部分需要重画，但是元素的尺寸没有改变")]),v._v(" "),e("li",[v._v("特点：重绘不一定导致重排；重排一定会导致重绘，因为重绘是浏览器渲染页面的最后一步")])])]),v._v(" "),e("li",[e("p",[v._v("阻止事件冒泡&取消默认行为")]),v._v(" "),e("ul",[e("li",[v._v("阻止事件冒泡")])]),v._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[v._v("w3c：e"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[v._v("stopPropagation")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\nie9以下：e"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("cancelBubble "),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[v._v("true")]),v._v("\n")])]),v._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[v._v("1")]),e("br"),e("span",{staticClass:"line-number"},[v._v("2")]),e("br")])]),e("ul",[e("li",[v._v("取消默认行为")])]),v._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[v._v("w3c：e"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[v._v("preventDefault")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\nie：e"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("returnValue "),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[v._v("false")]),v._v("\n")])]),v._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[v._v("1")]),e("br"),e("span",{staticClass:"line-number"},[v._v("2")]),e("br")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("cookies，sessionStorage")]),v._v(" 和 "),e("code",[v._v("localStorage")]),v._v(" 的区别？")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("cookie")]),v._v("是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密），数据会在浏览器和服务器间来回传递。存储量小只有几kb。设置自动过期之前一直有效。")]),v._v(" "),e("li",[e("code",[v._v("sessionStorage")]),v._v("和"),e("code",[v._v("localStorage")]),v._v("不会自动把数据发给服务器，仅在本地保存，"),e("code",[v._v("sessionStorage")]),v._v("窗口页面关闭就消失，"),e("code",[v._v("localStorage")]),v._v("一直在本地存在，除非手动清除。")])])]),v._v(" "),e("li",[e("p",[v._v("如何实现浏览器内多个标签页之间的通信")]),v._v(" "),e("ul",[e("li",[v._v("本地存储，或cookie")])])]),v._v(" "),e("li",[e("p",[v._v("前端性能优化的方式")]),v._v(" "),e("ul",[e("li",[v._v("1.减少dom操作")]),v._v(" "),e("li",[v._v("2.部署前，图片压缩，代码压缩")]),v._v(" "),e("li",[v._v("3.优化js代码结构，减少冗余代码")]),v._v(" "),e("li",[v._v("4.减少http请求，合理设置 HTTP缓存")]),v._v(" "),e("li",[v._v("5.使用内容分发cdn加速")]),v._v(" "),e("li",[v._v("6.静态资源缓存")]),v._v(" "),e("li",[v._v("7.图片延迟加载")])])]),v._v(" "),e("li",[e("p",[v._v("什么是webSocket")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("webSocket")]),v._v("是一种双向通信协议，允许服务器向客户端发送消息，一旦建立链接，便一直持续。")])])]),v._v(" "),e("li",[e("p",[v._v("HTTP状态码及其含义")]),v._v(" "),e("ul",[e("li",[v._v("404 找不到资源")]),v._v(" "),e("li",[v._v("400一般是请求错误，可能是参数传递错误")]),v._v(" "),e("li",[v._v("500 服务器错误")]),v._v(" "),e("li",[v._v("4开始一般都是客服端错误，5开头一般都是服务器错误")])])]),v._v(" "),e("li",[e("p",[v._v("什么是同源策略")]),v._v(" "),e("ul",[e("li",[v._v("域名，端口，协议相同。")])])]),v._v(" "),e("li",[e("p",[v._v("怎么跨域访问")]),v._v(" "),e("ul",[e("li",[v._v("jsonp")]),v._v(" "),e("li",[v._v("proxy")]),v._v(" "),e("li",[v._v("iframe")])])]),v._v(" "),e("li",[e("p",[v._v("什么是BFC、可以解决哪些问题")]),v._v(" "),e("ul",[e("li",[v._v("BFC是块格式化上下文，是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。")]),v._v(" "),e("li",[v._v("产生bfc的方法\n"),e("ul",[e("li",[v._v("float有值且不为空。")]),v._v(" "),e("li",[v._v("overflow有值且不为visible。")]),v._v(" "),e("li",[v._v("display有值为：inline-block，table-cell，flow-root，table-caption，inline-flex中的一个。")]),v._v(" "),e("li",[v._v("position有值为absolute或者fixed。")])])]),v._v(" "),e("li",[v._v("解决布局错乱，外边距重叠。")])])]),v._v(" "),e("li",[e("p",[v._v("let、const、var区别")]),v._v(" "),e("ul",[e("li",[v._v("var声明变量存在变量提升,let和const不存在变量提升，声明的变量不存在块级作用域。")]),v._v(" "),e("li",[v._v("let不存在变量提升，声明的变量有块级作用域。")]),v._v(" "),e("li",[v._v("const只能声明一个常量，不可以改变值，声明就要赋值，有块级作用域。")])])]),v._v(" "),e("li",[e("p",[v._v("箭头函数与普通函数的区别")]),v._v(" "),e("ul",[e("li",[v._v("箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值，箭头函数没有原型属性，箭头函数是匿名函数，不能作为构造函数，不能使用new")])])]),v._v(" "),e("li",[e("p",[v._v("promise")]),v._v(" "),e("ul",[e("li",[v._v("promise就是将异步任务队列化，将多个异步任务按照顺序输出，同时用链式调用解决回调地狱的问题。")])])]),v._v(" "),e("li",[e("p",[v._v("ES6的继承与ES5相比有什么不同")]),v._v(" "),e("ul",[e("li",[v._v("采用class关键字来定义父类")]),v._v(" "),e("li",[v._v("constructor是类的默认方法，没有显式定义时会默认建造一个空的constructor")]),v._v(" "),e("li",[v._v("通过extends关键字实现继承")]),v._v(" "),e("li",[v._v("子类必须在constructor方法中调用super()方法")])])]),v._v(" "),e("li",[e("p",[v._v("防抖和节流")]),v._v(" "),e("ul",[e("li",[v._v("函数防抖和节流，都是控制事件触发频率的方法。")]),v._v(" "),e("li",[v._v("所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。")]),v._v(" "),e("li",[v._v("所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。")])])]),v._v(" "),e("li",[e("p",[v._v("get和post的区别")]),v._v(" "),e("ul",[e("li",[v._v("get参数拼接在url上面，有长度限制，能够直接在浏览器导航栏请求，查看返回的结果，请求速度比较快，传输数据量少。")]),v._v(" "),e("li",[v._v("post参数放在请求体里面，能够传递大量数据，传输稳定，且没有参数没有限制。")])])]),v._v(" "),e("li",[e("p",[v._v("事件捕获，事件冒泡，事件委托")]),v._v(" "),e("ul",[e("li",[v._v("事件捕获当鼠标点击或者触发dom事件时（被触发dom事件的这个元素被叫作事件源），浏览器会从根节点 =>事件源（由外到内）进行事件传播。")]),v._v(" "),e("li",[v._v("事件冒泡，事件捕获当鼠标点击或者触发dom事件时事件从子元素触发，向外扩展，触发父元素的事件。")]),v._v(" "),e("li",[v._v("事件委托,父元素里面有很多相同标签的子元素，需要给子元素绑定事件，使用事件委托只需要把事件绑定在父元素上面,通过event.target进行事件触发。大量节省内存占用，减少事件注册，当新增子对象时无需再次对其绑定")])])]),v._v(" "),e("li",[e("p",[v._v("call、apply、bind 的用法以及区别")]),v._v(" "),e("ul",[e("li",[v._v("相同 改变函数体内 this 的指向。")]),v._v(" "),e("li",[v._v("不同call、apply的区别：接受参数的方式不一样。bind：不立即执行。而apply、call 立即执行。apply的第二个参数必须是一个包含多个参数的数组")])])]),v._v(" "),e("li",[e("p",[v._v("ES5/ES6 的继承除了写法以外还有什么区别？")]),v._v(" "),e("ul",[e("li",[v._v("ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加 到 this 上(Parent.apply(this))")]),v._v(" "),e("li",[v._v("ES5 的继承时通过原型或构造函数机制来实现。")]),v._v(" "),e("li",[v._v("ES6 通过 class 关键字定义类，里面有构造方法，类之间通过 extends 关 键字实现继承。")]),v._v(" "),e("li",[v._v("ES6 的继承机制完全不同，实质上是先创建父类的实例对象 this(所以必 须先调用父类的\nsuper()方法)，然后再用子类的构造函数修改 this。\\")])])]),v._v(" "),e("li",[e("p",[v._v("setTimeout、Promise、Async/Await 的区别")]),v._v(" "),e("ul",[e("li",[v._v("setTimeout是异步执行函数 , 当js主线程运行到此函数时,不会等待settimeout中的回调函数 ,会直接进行settimeout下面的语句(尽管setTimeout的延迟时间为0时) 当执行完当前事件循环的时候,settimeout中的回调会在下次(或者某一个)事件循环中被执行。")]),v._v(" "),e("li",[v._v("Promise 本身是同步的立即执行函数,当在执行体中执行resolve()或者reject的时候,此时是异步操作\n会先执行then/catch(异步执行)等,等主栈完成后,才会去执行resolve()/reject中的方法,")]),v._v(" "),e("li",[v._v("async函数返回一个promise对象,当函数执行的时候,一旦遇到await就会先返回,等到触发的异步操作完成(await的函数),在执行函数体后面的语句,可以理解为,async让出了线程,跳出了async函数体,因此await函数后的语句相当于在then回调中执行.await的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。")])])]),v._v(" "),e("li",[e("p",[v._v("JS 异步解决方案的发展历程以及优缺点。")]),v._v(" "),e("ul",[e("li",[v._v("回调函数   缺点：回调地狱，不能用 try catch 捕获错误，不能 return，优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）")]),v._v(" "),e("li",[v._v("promise  优点：解决了回调地狱的问题，无法取消 Promise ，错误需要通过回调函数来捕获")]),v._v(" "),e("li",[v._v("async await 代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题，await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。")])])]),v._v(" "),e("li",[e("p",[v._v("Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？")]),v._v(" "),e("ul",[e("li",[v._v("promise构造函数是同步执行的，then方法是异步执行的")])])]),v._v(" "),e("li",[e("p",[v._v("cookie 和 token 都存放在 header 中，为什么不会劫持 token")]),v._v(" "),e("ul",[e("li",[v._v("浏览器会自动带上cookie，而浏览器不会自动带上token")])])]),v._v(" "),e("li",[e("p",[v._v("const 和 let 声明的变量不在 window ，在哪里？")]),v._v(" "),e("ul",[e("li",[v._v("var 声明的变量在window上。属于顶层对象的属性。")]),v._v(" "),e("li",[v._v("let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。在全局作用域中，用 let 和 const 声明的全局变量并没有在全局对象中，只是一个块级作用域（Script）中")])])]),v._v(" "),e("li",[e("p",[v._v("为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作？")]),v._v(" "),e("ul",[e("li",[v._v("vuex和redux都是一种状态管理机制。然后他们会有自己的state（状态）和修改state的方法，修改state的方法涉及到同步和异步，vuex的处理方式是同步在mutation里面，异步在actions里面，然后redux的同步就是reducer,异步更多的是用户自己去通过中间件的方式去实现")])])]),v._v(" "),e("li",[e("p",[v._v("call 和 apply 的区别是什么，哪个性能更好一些")]),v._v(" "),e("ul",[e("li",[v._v("传递参数不一样，apply传递参数只能有两个，一个是this,一个数组里面是其它参数，call参数个数没有限制。")]),v._v(" "),e("li",[v._v("call的性能好一点。")])])]),v._v(" "),e("li",[e("p",[v._v("什么是作用域链")]),v._v(" "),e("ul",[e("li",[v._v("在局部作用域中，访问一个变量时，系统首先会在当前作用域中寻找变量var的声明语句，如找到则直接使用。反之，则继续向上一级作用域中寻找var的声明语句，如找到则直接使用，反之，继续向上一级作用域中去寻找…直到全局作用域，如找到则直接使用，如未找到则直接在全局作用域中声明该变量，我们把这种链式查询关系就称之为为作用域链！")])])]),v._v(" "),e("li",[e("p",[v._v("什么是面向对象")]),v._v(" "),e("ul",[e("li",[v._v("面向对象会把事物抽象成对象的概念，就是说这个问题里面有哪些对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法，问题得到解决。")])])]),v._v(" "),e("li",[e("p",[v._v("什么是面向过程")]),v._v(" "),e("ul",[e("li",[v._v("当解决一个问题的时候，面向过程会把事情拆分成： 一个个函数和数据（用于方法的参数） 。然后按照一定的顺序，执行完这些方法（每个方法看作一个过程），等方法执行完了，事情就搞定了。")])])]),v._v(" "),e("li",[e("p",[v._v("js有void类型的数据吗？")]),v._v(" "),e("ul",[e("li",[v._v("这是一个面试官问我的，我回答的是没有，他说用过，我就很纳闷"),e("code",[v._v("ts")]),v._v("才有"),e("code",[v._v("void")]),v._v(",跟他确认之后，他还是坚持说有，说自己在用，面试完回来查了一下，"),e("code",[v._v("js")]),v._v("的"),e("code",[v._v("void")]),v._v("是一元运算符，也不是数据类型，所以这个人说错了。")])])])]),v._v(" "),e("h2",{attrs:{id:"vue面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue面试题"}},[v._v("#")]),v._v(" Vue面试题")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("什么是MVVM？")]),v._v(" "),e("ul",[e("li",[v._v("MVVM是Model-View-ViewModel的缩写。MVVM是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。")])])]),v._v(" "),e("li",[e("p",[v._v("什么是MVC")]),v._v(" "),e("ul",[e("li",[v._v("MVC全名是Model View Controller，是一种软件设计模式，其中可分为模型(model)－视图(view)－控制器(controller)三要素，")])])]),v._v(" "),e("li",[e("p",[v._v("vue中的watch可以监听哪些值？")]),v._v(" "),e("ul",[e("li",[v._v("vue中的watch监听，除了监听data中的数据,还可以监听 props 、$route 、$emit 、computed.")])])]),v._v(" "),e("li",[e("p",[v._v("watch与computed的区别")]),v._v(" "),e("ul",[e("li",[v._v("watch是监听data定义的属性，一旦data定义的属性改变就会触发watch")]),v._v(" "),e("li",[v._v("computed 依赖于data定义的属性，一旦data定义的属性改变也会触发computed，return一个结果。")])])]),v._v(" "),e("li",[e("p",[v._v("vue生命周期及对应的行为")]),v._v(" "),e("ul",[e("li",[v._v("befroeCreate 创建之前调用")]),v._v(" "),e("li",[v._v("created 创建完成，dom还没有渲染完成调用")]),v._v(" "),e("li",[v._v("mounted  dom渲染完成调用")]),v._v(" "),e("li",[v._v("beforeUpdate 更新之前调用")]),v._v(" "),e("li",[v._v("updated 更新完成后调用")]),v._v(" "),e("li",[v._v("beforeDestroy 销毁之前调用")]),v._v(" "),e("li",[v._v("destroyed 销毁后调用")])])]),v._v(" "),e("li",[e("p",[v._v("组件间通讯方法")]),v._v(" "),e("ul",[e("li",[v._v("props，$emit $parent $children provide  ref")])])]),v._v(" "),e("li",[e("p",[v._v("vue.nextTick实现原理")]),v._v(" "),e("ul",[e("li",[v._v("Vue在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新，然后更新完成触发nextTick。")])])]),v._v(" "),e("li",[e("p",[v._v("在 Vue 中，子组件为何不可以修改父组件传递的 Prop")]),v._v(" "),e("ul",[e("li",[v._v("props是单向数据流，如果有多个子组件公用父组件的props,一旦子组件修改，其它的子组件的状态也会被影响，容易造成数据混乱。")])])]),v._v(" "),e("li",[e("p",[v._v("双向绑定和 vuex 是否冲突")]),v._v(" "),e("ul",[e("li",[v._v("在严格模式中使用 Vuex 时，在属于 Vuex 的 state 上使用 v-model 会导致出错。因为将vuex的state双向绑定后，视图输入的值变化，双向绑定就会修改state，但是不是通过mutation来修改，vuex修改state的唯一途径就是mutation，所以就会导致出错。")]),v._v(" "),e("li",[v._v("解决方式就是不要双向绑定state。")])])]),v._v(" "),e("li",[e("p",[v._v("Vue 的响应式原理中 Object.defineProperty 有什么缺陷？为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty？")]),v._v(" "),e("ul",[e("li",[v._v("Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy可以劫持整个对象，并返回一个新的对象。Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性")])])])])])}),[],!1,null,null,null);_.default=l.exports}}]);